# -------------------- Initialization and Saving Functions --------------------


def split(df, validation_ratio):
    X = df.loc[:, "f1":"REDSHIFT_SPEC"]
    y = df.loc[:, "REDSHIFT_SPEC"]
    train, test = h2o.H2OFrame(X).split_frame(ratios=[validation_ratio], seed=1)

    return X, y, train, test


def auto_ML(df, n_models, validation_ratio=0.5):
    """
    Initialize h2o, a new Auto ML object and already train it applying verification following the validation ratio.
    """
    h2o.init(ip="localhost", port=54323)
    aml = H2OAutoML(max_models=n_models, seed=1)
    X, y, train, test = split(df, validation_ratio)

    aml.train(
        x=list(df.loc[:, "f1":"f20"].columns),
        y="REDSHIFT_SPEC",
        training_frame=train,
        leaderboard_frame=test,
    )

    lb = aml.leaderboard
    print("Leaderboard: ", lb.head(rows=lb.nrows), "\n")
    print("Leader: ", aml.leader, "\n")

    return aml


def save_aml_models(aml):
    """
    Save all aml object models on the respective folder.
    """
    aml_pd = aml.leaderboard.as_data_frame(use_pandas=True)
    lb = aml.leaderboard
    path = f"../../models/mojo_{len(lb)-2}_ensemble/"

    for i in range(len(lb)):
        model = h2o.get_model(aml_pd["model_id"][i])
        model.save_mojo(path, force=True)
        print(f"Model {aml_pd['model_id'][i]} saved.")


# -------------------- Prediction Related Functions --------------------


def read_models(path):
    """
    Return dict of models inside specified folder.
    """
    for (dirpath, dirnames, filenames) in walk(path):
        pass
    models = {}
    for file in filenames:
        models[file] = h2o.import_mojo(f"../../models/mojo_50_ensemble/{file}")
    return models


def gen_predictions(df, model, validation_ratio=0.5, return_len=True):
    """
    Receives DataFrame and model, it split the frame and returns predictions and len of splits.
    """
    X, y, train, test = split(df, validation_ratio)
    preds = model.predict(h2o.H2OFrame(X.iloc[-len(test) :].loc[:, "f1":"f20"]))
    print(
        "\n",
        f"{len(train)} train/test objects ",
        "\n",
        f"and {len(test)} validation objects",
    )
    if return_len:
        return preds, len(train), len(test)
    return preds


def gen_models_predictions(df, models, validation_ratio=0.5):
    """
    Receives DataFrame, dict fo models and returns a DataFrame with N + 1 columns.
    N is the number of models on dict (including Stacked Ensemble) plus the true value as first column (REDSHIFT_SPEC).
    """
    X, y, train, test = split(df, validation_ratio)

    df_predictions = pd.DataFrame(X.iloc[-len(test) :]["REDSHIFT_SPEC"])
    df_predictions.reset_index(inplace=True)
    for model_name in models.keys():
        preds = gen_predictions(
            df, models[model_name], validation_ratio=validation_ratio, return_len=False
        )
        df_ = preds.as_data_frame()
        df_.columns = [model_name]
        df_predictions = pd.concat([df_predictions, df_], axis=1)

    df_predictions.set_index("ID", inplace=True)
    return df_predictions


def gen_gaussian_kde(preds, points=100):
    """
    Return gaussian_kde values after receiving the prediction values.
    """
    pdf = gaussian_kde(preds).pdf(np.linspace(preds.min(), preds.max(), points))
    return pdf, np.linspace(preds.min(), preds.max(), points)


def print_gaussian_kde(pdf, preds, real_value, best_pred, title, points=100):
    """
    Receives the Probability Density Function generated by gaussian KDE method and prints it
    with the best prediction, real value and a histogram distribution.
    """
    fig, axs = plt.subplots(nrows=1, ncols=1, figsize=(8, 5))
    axs.axvline(best_pred, c="k", ls="--", lw="3", label="Best prediction")
    axs.axvline(real_value, c="r", ls="--", lw="3", label="Real value")
    axs.hist(preds, density=True, histtype="step", label="Models prediction histogram")
    axs.legend(loc="best")
    axs.set_title(title)
    axs.plot(np.linspace(preds.min(), preds.max(), points), pdf)


def gen_df_gaussian_kde(df_predictions, export_csv=False, **kwargs):
    ans = copy.deepcopy(df_predictions)
    predictions = df_predictions.loc[
        :, df_predictions.columns[1] : df_predictions.columns[-1]
    ].values.reshape(len(df_predictions), 52)
    ans["PDF"], ans["PDF_X_axis"], ans["predictions"] = None, None, None
    for i in range(len(predictions)):
        ans["PDF"].iloc[i], ans["PDF_X_axis"].iloc[i] = gen_gaussian_kde(predictions[i])
        ans["predictions"].iloc[i] = predictions[i]
    if export_csv:
        ans[
            [
                "REDSHIFT_SPEC",
                kwargs.get("best_model"),
                "PDF",
                "PDF_X_axis",
                "predictions",
            ]
        ].to_csv(kwargs.get("path"))
    return ans[
        ["REDSHIFT_SPEC", kwargs.get("best_model"), "PDF", "PDF_X_axis", "predictions"]
    ]
